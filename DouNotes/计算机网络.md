# 计算机网络

## OSI七层、TCP/IP四层的关系和区别？
七层模型，亦称OSI（Open System Interconnection），它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。

OSI七层从上往下依次为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvibHWWiaj1RKAjY6ia2icfkj9Ihk3MSRkzj5nbDWn6HlssjpNLCq3JEzCng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

TCP/IP四层从上往下依次是：应用层、传输层、网络层（互联网层）、链路层（数据链路层/网络接口层）。与 OSI 七层的映射关系如下：
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvytAC5DQCyMibn0iaBHnJlkpwIcMShGqxzUiblYicH1NUnIPoRzb8DyCMrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

OSI七层和TCP/IP的区别：
- TCP/IP 是一个协议簇；而 OSI 则是一个模型。 
- TCP/IP 是由一些交互性的模块做成的分层次的协议，其中每个模块提供特定的功能；OSI 则指定了哪个功能是属于哪一层的。 
- TCP/IP 四层是 OSI 七层的简化版。

附一张经典图：
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvic4gHT7n4lLLHXy4no98VUr3zEecJc1WkptTc22icHpgwRxN2PrnKib3g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 2. TCP 与 UDP 的区别？
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvzKhLDwdMzE99oE54Ec9KLMOfmCNiaCKlocI4vRW7xFO6JLbVclmgd0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
小结TCP和UDP的区别
- TCP基于连接，UDP无连接
- 对系统的要求(TCP较多，UDP较少)
- TCP流模式，UDP数据报模式
- TCP保证数据正确性且保证数据顺序
- UDP可能丢包且不保证数据顺序

## 3. TCP 是如何实现数据的可靠性？
一句话：通过校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制等机制来保证可靠性。

（1）校验和

在数据传输过程中，将发送的数据段都当做一个16位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在最后，然后取反，得到校验和。

发送方：在发送数据之前计算校验和，并进行校验和的填充。接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。

（2）序列号

TCP 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答作用，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复的数据。

（3）ACK 确认应答

当消息接收方接收到消息，返回一个对应的 ACK，发送方就知道这个消息已经处理完成，这个 ACK 报文中带有对应的确认序列号，告诉发送方，接收了哪些数据，下一次数据从哪里传。

（4）超时重传

消息超时也就是说没有在等待时间内收到对方的 ACK 消息。这个时候，为了保证消息对方能够正确收到，我们需要将这个消息进行重新传输，如果尝试成功，则继续发送接下来的包。若尝试几次均失败，那么 TCP 会强行断开连接，发送 RST 信息。并告知应用程序连接错误。

（5）连接可靠

三次握手、四次挥手的过程。

（6）流量控制

如果发送方的发送速度太快，会导致接收方的接收缓冲区填充满了，这时候继续传输数据，就会造成大量丢包，进而引起丢包重传等等一系列问题。TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制机制。

具体实现方式：接收端将自己的接收缓冲区大小放入 TCP 首部的『窗口大小』字段中，通过 ACK 通知发送端。

（7）拥塞控制

TCP 传输过程中一开始就发送大量数据，如果当时网络非常拥堵，可能会造成拥堵加剧。所以 TCP 引入了慢启动机制，在开始发送数据的时候，先发少量的数据探探路。

## 4. TCP 滑动窗口
TCP 会将较大数据拆分成一个个小的数据包再进行发送。发送完一个包，等待 ACK，这种模式是最简单的。但是问题也很明显，慢，吞吐量低。所以我们在等待 ACK 的同时，可以继续发送接下来的包。也就是说，滑动窗口就是在发送完一个数据包后，不需要等待 ACK 消息返回，可以发送后面的数据包，解决吞吐量问题。

发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
![](https://mmbiz.qpic.cn/mmbiz_gif/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgve24m7Y2RoHmxwxollKNctMtIjZu8wicNmklPxFgJIjfbOpfavFUjb4w/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

### 4.1 窗口的概念
发送方的发送缓存内的数据都可以被分为4类:

已发送，已收到ACK
已发送，未收到ACK
未发送，但允许发送
未发送，但不允许发送
其中类型2和3都属于发送窗口。

接收方的缓存数据分为3类：

已接收
未接收准备接收
未接收并未准备接收
其中类型2属于接收窗口。
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvQViaialmWbNVFRjU7fAB0kUnI4iazicrebp36hlh7WjRh0nH4s0sr6zoGA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
TCP header中有一个Window Size字段，它其实是指接收端的窗口，即接收窗口。用来告知发送端自己所能接收的数据量，从而达到一部分流控的目的。

### 4.2 滑动机制
发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。

接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保发送端会对这些数据重传。

遵循快速重传、累计确认、选择确认等规则。

## 5. 拥塞控制
防止发送方发地太快，使得网络来不及处理，从而导致网络拥塞。

❝
如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。
❞
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvhfCtyHK4icjOoicdOVB7ft9WKiaAjvrCvIeiab2KvjZcokoBTYuicHsd9uw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
拥塞控制的方法主要有以下四种：

1.慢启动：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。  
2.拥塞避免：
- 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。 
- 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ... 
- 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 
- 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgv826kNzmKtaXZeV5QGJBzM1083O7UD0jKSichibic3icqgZrItvrNVb7T0Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
3.快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvBZY2ShEFSEro83Xzg1ibMYBcZjsKGRVu7zQYIianRG8Tlp96zZdAMsuQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
4.快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。
- 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。
- 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。
- 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

## 6.三次握手和四次挥手
TCP报文段
![](https://s1.ax1x.com/2018/03/02/9rzlJf.png)
字段解释：

- 序号字段（就是seq）：序号字段的值指的是本报文段所发送的数据的第一个字节的序号。
- 确认号字段（就是ack）：是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N, 则表明到序号N-1为止的所有数据都已正确收到。（累积确认）
- 「确认位ACK」：只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把ACK置1。
- 「同步位SYN」。同步SYN=1表示这是一个连接请求或连接接收报文。当SYN= 1, ACK=0 时，表明这是一个连接请求报文，对方若同意建立连接，则在响应报文中使用SYN= 1, ACK=1。TCP建立连接用到。
- 「终止位FIN (Finish)」 。用来释放一个连接。FIN=1表明此报文段的发送方的数据已发送完毕了并要求释放传输连接。TCP断开连接用到。
- URG(紧急) 当URG=1,表明紧急指针字段有效，该报文段有紧急数据，应尽快发送。
- PSH(推送) 接收方接收到PSH=1的报文段，会尽快交付接收应用进程，不再等待整个缓存填满再交付。实际较少使用。
- RST(复位) RST=1时，表明TCP连接中出现严重差错，必须是否连接，再重连。

有了上面的铺垫，再来看下面这图就容易明白了吧？
![](https://cdn.jsdelivr.net/gh/qiaocci/img-repo@master/20210428181424.png)
1.第一次握手：客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发给服务端，客户端进入syn_sent状态，等待服务器确认。   
2.第二次握手：服务端收到数据包后由标志位SYN=1，直到客户端再请求建立连接，服务端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。
3.第三次握手：客户端收到确认后检查，如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务器，服务器进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后将客户端和服务端之间可以开始传输数据了。

### 为什么需要三次握手，最后一次如果没有行不行，会有什么问题？
不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值。    
如果只是两次握手，至多只有客户端的起始序列号能被确认，服务器端的序列号则得不到确认。

### TCP四次挥手过程
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgv13kvWEU7DoEp6scM5KA6vE6DfnqmVMBiagAcBGbict01a3ApgyicywibMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
1.第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。   
2.第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。    
3.第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务器进入Last_ack状态。   
4.第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。

### 6.3 为什么四次挥手释放连接时需要等待2MSL
MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。

### 6.4 为什么TCP挥手需要4次
主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。

所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。

### 6.5 TCP 三次握手能否携带数据？
第三次是可以携带数据的。

假如第一次握手可以携带数据的话，如果恶意攻击服务器，每次都在第一次握手中的SYN报文中放入大量数据。而且频繁重复发SYN报文，服务器会花费很多的时间和内存空间去接收这些报文。

第三次握手，此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。

### 6.6 三次握手连接阶段，最后一次ACK包丢失，会发生什么？
服务端：   
第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。

客户端：   
客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。

## 7. TCP 半连接队列和全连接队列是什么？
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvHkvuzlruItRrI5DcI1npeUico8V5RicAEXSfgfRmlrA1qy0GZFIiaHZuA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
服务端收到客户端发出的 SYN 请求后，会把这个连接信息存储到半链接队列(SYN 队列)。

服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到全连接队列(accept 队列)，等待进程调⽤ accept 函数时把连接取出来。

这两个队列都是有大小限制的，当超过容量后就会将链接丢弃，或者返回 RST 包。

## 8. 粘包/拆包是怎么发生的？怎么解决这个问题？
TCP 发送数据时会根据 TCP 缓冲区的实际情况进行包的划分，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是 TCP 粘包和拆包问题。
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgv71M8uKg2ic1NlibBsJlaDDwWiaU2XHs949BvDicjGbqyljib4aPeTZR6GyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
发生 TCP 粘包的原因:

1.发送的数据小于 TCP 缓冲区大小，TCP 将缓冲区中的数据一次发送出去可能就会发生粘包。   
2.接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

发生 TCP 拆包的原因:

1.待发送数据大于最大报文长度，TCP 在传输前将进行拆包。   
2.发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。

解决方案:

1.发送端给每个数据包添加包首部，首部中包含数据包的长度，这样接收端在接收到数据后，通过该字段就可以知道每个数据包的实际长度了。   
2.发送端将每个数据包设置固定长度，这样接收端每次从读取固定长度的数据把每个数据包拆分开。   
3.可以在数据包之间设置边界，如添加特殊符号，接收端可以通过这个特殊符号来拆分包。

## 9.DNS协议
DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。

### 9.1 DNS解析过程
1.在浏览器中输入www.baidu.com域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有就先调用这个IP地址映射，完成域名解析。

2.如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有直接返回，完成域名解析。

3.如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。

4.如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。

5.如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至13台根 DNS ，根 DNS 服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地 DNS 服务器收到IP信息后，将会联系负责 .com 域的这台服务器。这台负责 .com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(baidu.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 baidu.com 域服务器，重复上面的动作，进行查询，直至找到 www.baidu.com 主机。

6.如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用的是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。

## 10. 在浏览器中输入www.baidu.com后执行的全部过程？
域名解析 -> 建立TCP连接（三次握手）-> 发起http请求 -> 服务器响应http请求，浏览器得到html代码 -> 浏览器解析html代码，并请求html代码中的资源（如 js、css、图片等）-> 浏览器对页面进行渲染呈现给用户。

## 11. IP地址是怎样分类的？
先说一下 IP 的基本特点：

IP地址由四段组成，每个字段是一个字节，8位，最大值是255。IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。

IP 地址主要分为A、B、C三类及特殊地址D、E这五类:
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvdubkLqKJCZlGAJicvv4sKyPFIwmD0XiaufGS9uaR07emqULBn91Htnkg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
- A类：(1.0.0.0-126.0.0.0)一般用于大型网络。 
- B类：(128.0.0.0-191.255.0.0)一般用于中等规模网络。 
- C类：(192.0.0.0-223.255.255.0)一般用于小型网络。 
- D类：是多播地址，地址的网络号取值于224~239之间，一般用于多路广播用户。 
- E类：是保留地址。地址的网络号取值于240~255之间。

## 12. 常用端口号
| 端口  | 	服务         | 
|-----|-------------|
| 21	 | FTP（文件传输协议） |   
|22	|SSH（安全外壳协议）   |
|23	|Telnet（internet远程登录服务的标准协议   |
|25	|SMTP简单邮件传输服务    |
|53	|DNS（域名系统服务）   |
|80	|HTTP（超文本传输协议）   |

## 13. HTTP协议
http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。

### 13.1 简述http状态码和对应的信息
1XX：接收的信息正在处理   
2XX：请求成功，请求被成功处理 200 OK    
3XX：重定向   
4XX：客户端错误   
5XX：服务端错误   
常见错误码：
```
12. 常用端口号
端口	服务
21	FTP（文件传输协议）
22	SSH（安全外壳协议）
23	Telnet（internet远程登录服务的标准协议
25	SMTP简单邮件传输服务
53	DNS（域名系统服务）
80	HTTP（超文本传输协议）
13. HTTP协议
http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。

13.1 简述http状态码和对应的信息
1XX：接收的信息正在处理
2XX：请求成功，请求被成功处理 200 OK
3XX：重定向
4XX：客户端错误
5XX：服务端错误
```

### 13.2 转发和重定向的区别
转发是服务器行为。服务器直接向目标地址访问 URL,将相应内容读取之后发给浏览器，用户浏览器地址栏 URL不变，转发页面和转发到的页面可以共享 request 里面的数据。

重定向是利用服务器返回的状态码来实现的，如果服务器返回 301 或者 302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏 URL 会发生改变，而且不能共享数据。

### 13.3 http中常见的header字段有哪些？
请求头：
```
Accept: text/html,image/*( 浏览器可以接收的类型) 
Accept-Charset: ISO-8859-1(浏览器可以接收的编码类型) 
Accept-Encoding: gzip,compress(浏览器可以接收压缩编码类型) 
Accept-Language: en-us,zh-cn(浏览器可以接收的语言和国家类型) 
Host: www.it315.org:80(浏览器请求的主机和端口) 
If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(某个页面缓存时间) 
Referer: http://www.it315.org/index. jsp(请求来自于哪个页面) 
User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)(浏览器相关信息) 
Cookie：(浏览器暂存服务器发送的信息) 
Connection: close(1.0)/Keep-Alive(1.1)(HTTP请求的版本的特点) 
Date: Tue, 11 Jul 2000 18:23:51 GMT(请求网站的时间) 
```
响应头：
```
Location: http://www.wekenw.com (控制浏览器显示哪个页面) 
Server:apache tomcat(服务器的类型) 
Content-Encoding: gzip(服务器发送的压缩编码方式) 
Content-Length: 80(服务器发送显示的字节码长度) 
Content-Language: zh-cn(服务器发送内容的语言和国家名) 
Content-Type: image/jpeg; charset=UTF-8(服务器发送内容的类型和编码类型) 
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务器最后一次修改的时间) 
Refresh: 1;url=http://www.it315.org(控制浏览器1秒钟后转发URL所指向的页面) 
Content-Disposition: attachment; filename=aaa.jpg(服务器控制浏览器发下载方式打开文件) 
Transfer-Encoding: chunked(服务器分块传递数据到客户端）  
Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务器发送Cookie相关的信息) 
Expires: -1(服务器控制浏览器不要缓存网页，默认是缓存) 
Cache-Control: no-cache(服务器控制浏览器不要缓存网页) 
Pragma: no-cache(服务器控制浏览器不要缓存网页)   
Connection: close/Keep-Alive(HTTP请求的版本的特点)   
Date: Tue, 11 Jul 2000 18:23:51 GMT(响应网站的时间) 
```
### 13.4 简述http1.0
规定了请求头和请求尾，响应头和响应尾(get post)

每一个请求都是一个单独的连接，做不到连接的复用



### 13.5 简述http1.1的改进
HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

支持管道(pipeline)网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

服务端无法主动push

### 13.6 简述HTTP短连接与长连接区别
HTTP中的长连接短连接指HTTP底层TCP的连接。

短连接：客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。

长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。

### 13.7 简述http2.0的改进
提出多路复用。多路复用前，文件是串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。

引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。

### 13.8 http与https的区别
http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。

### 13.9 简述TLS/SSL, HTTP, HTTPS的关系
SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。

可以将HTTPS协议简单理解为HTTP协议+TLS/SSL

## 14. https 的连接过程
浏览器将支持的加密算法信息发给服务器

服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器

客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。

客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器

服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

服务器将加密后的密文发送给客户端

客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

## 15. Get与Post区别
- Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。
- Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。
- GET：请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。
- POST：的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而 POST 请求参数则被包装到请求体中，相对更安全。

## 16. cookie和session区别？
- 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID； 
- 大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关； 
- 安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全； 
- 服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。 
- 存放位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。

## 17. 计算机网络常用性能指标有：
1.速率：连接在计算机网络上的主机在数字信道上传送数据的速率。  
2.带宽：网络通信线路传送数据的能力。  
3.吞吐量：单位时间内通过网络的数据量。  
4.时延：数据从网络一端传到另一端所需的时间。  
5.时延带宽积：传播时延带宽。  
6.往返时间RTT：数据开始到结束所用时间。  
7.利用率信道：数据通过信道时间。  

##  18 网络安全
### 什么是 XSS 攻击？   
XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。XSS的重点不在于跨站点，而在于脚本的执行。

XSS的原理是：

恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。

XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。

### 什么是 CSRF？
CSRF（Cross Site Request Forgery，跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一，也被称为『One Click Attack』或者 『Session Riding』，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。

听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。

XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。

### 对称加密与非对称加密
对称密钥加密，又称私钥加密，即信息的发送方和接收方用同一个密钥去加密和解密数据。
- 最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难且较为不安全。 
- 进行一对一的双向保密通信。 
- 常见的对称加密算法：DES，AES等。
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvG6e7Rx3nicsDclANKrAqPkckJ3C2yVPVKs7UnHgnsEBsHomqkBtYyzw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

2.非对称密钥加密，又称公钥加密，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。
- 从功能角度而言非对称加密比对称加密功能强大且较为安全，但加密和解密速度却比对称密钥加密慢得多。 
- 多对一的单向保密通信。 
- 最常用的非对称加密算法：RSA

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

### 数字签名
数字签名必须保证实现以下三点功能：

报文鉴别。即接受者能够核实发送者对报文的签名。
报文的完整性。即接受者确信所收到的数据和发送者发送的完全一样而没有被篡改过。
不可否认。即发送者事后不能抵赖对报文的签名。
![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgv0jiccwrI3b8VWkwCqOLUqleZskJSWHHxJZmosbdiaYdF8Uh479ex3xJg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
该图只是进行了数字签名并没有对报文进行加密。

数字签名过程：A用私钥SKA对明文X进行D运算签名成为密文DSKA，B用A的公钥PKA对密文DSKA进行E运算还原出明文X。

那么这个过程是如何满足报文鉴别、报文的完整性、不可否认三个特点的呢？

- 只有A拥有私钥SKA，只有他能生成密文DSKA，所以只要B用A的公钥能成功还原出可读的明文X就说明密文DSKA一定是A发来的。这里体现出报文的鉴别的特点。
- 同理如果中途密文DSKA被篡改，那么篡改者没有A的私钥SKA来对篡改过后的报文进行加密，那么B对被篡改过的报文进行解密时就会得到不可读的明文，就知道收到的报文被修改过了。这里体现了报文的完整性的特点。 
- 若A抵赖曾发过该报文给B，B可把X和密文DSKA出示给进行公证的第三者，第三者很容易用PKA去证实A确实发送了X给B。这里体现了不可否认的特点。

![](https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6d9mXc6ZRdVKhFHkDUTjIgvdricZiazteh9cFIVh3icFvArIcCObQFtweB3VaTQ4uXF8XWbMSJgnZAXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
