
# Go基础

## slice
### slice实现原理
```go
type slice struct {
    array unsafe.Pointer
    len   int
	cap   int
}
```
在使用append向slice追加元素时，若slice空间不足则会发生扩容，扩容会重新分配一块更大的内存，将原slice拷贝到新slice，然后返回新slice。
扩容后再将数据追加进去。

扩容操作只对容量，扩容后的 slice 长度不变，容量变化规则如下：

- 若 slice 容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，
即每次增加原来容量的四分之一。
- 若 slice 容量够用，则将新元素追加进去，slice.len++，返回原 slice
- 若 slice 容量不够用，将 slice 先扩容，扩容得到新 slice，将新元素追加进新 slice，slice.len++，返回新 slice。

### slice copy
```go
/* 拷贝 numbers 的内容到 numbers1 */
   copy(numbers1,numbers)
```
使用 copy() 内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的的切片指向的数组中，拷贝数量取「两个切片长度的最小值」。

例如将长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。也就是说 「copy 不会发生扩容」。

1.根据数组或切片来生成新的切片一般使用slice := array[start:end]方式， 这种新生成的切片没有指定容量，
新切片的容量是从start开始到array的结束（注意并不是到 end）。

2.另一种写法，生成新切片同时指定其容量：slice[start:end:cap] ，其中的 cap 为新切片的容量，容量不能超过原切片实际值。

### Go中对nil的Slice和空Slice的处理是一致的吗?
首先Go的JSON 标准库对 nil slice 和 空 slice 的处理是不一致。

- `slice := make([]int,0）`：slice不为nil，但是slice没有值，slice的底层的空间是空的。
- `slice := []int{}` ：slice的值是nil，可用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值。
- nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址） 
- 空切片的引用数组指针地址是有的，且固定为一个值


## map
### Golang Map 底层实现
Golang 中 map的底层实现是一个散列表，因此实现 map的过程实际上就是实现散表的过程。在这个散列表中，主 要出现的结构体有两个，
一个叫 hmap(a header for a go map)，一个叫 bmap(a bucket for a Go map，通常叫 其bucket)。

### Go中的map如何实现顺序读取？
Go中map如果要实现顺序读取的话，可以先把map中的key，通过sort包排序。

## chan原理
[chan实现原理](https://mp.weixin.qq.com/s?__biz=Mzk0NzI3Mjk1Mg==&mid=2247484584&idx=1&sn=9ac5ec75fe2c6177c8ca48c711fa021d&scene=21#wechat_redirect)
### 结构体
```go
type hchan struct {
	qcount   uint  // 队列中的总元素个数
    dataqsiz uint  // 环形队列大小，即可存放元素的个数
    buf      unsafe.Pointer // 环形队列指针
    elemsize uint16  //每个元素的大小
    closed   uint32  //标识关闭状态
    elemtype *_type // 元素类型
	
    sendx    uint   // 发送索引，元素写入时存放到队列中的位置
    recvx    uint   // 接收索引，元素从队列的该位置读出
    recvq    waitq  // 等待读消息的goroutine队列
    sendq    waitq  // 等待写消息的goroutine队列
    lock mutex  //互斥锁，chan不允许并发读写
}
```

### 向 channel 写数据
过程如下：

1.若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。  
2.若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。  
3.若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。  

### 从 channel 读数据
过程如下：

1.若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程；  
2.如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程；  
3.如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；  
4.将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒；  

### 关闭channel
关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。

panic 出现的场景还有：

关闭值为 nil 的 channel
关闭已经关闭的 channel
向已经关闭的 channel 中写数据

### 对已经关闭的的 chan 进行读写，会怎么样？为什么？
- 读已经关闭的 chan 能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。  
如果 chan 关闭前，buffer 内有元素还未读 , 会正确读到 chan 内的值，且返回的第二个 bool 值（是否读成功）为 true。  
如果 chan 关闭前，buffer 内有元素已经被读完，chan 内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个 bool 值一直为 false。  
- 写已经关闭的 chan 会 panic  

### channel 为什么它可以做到线程安全？
Channel 可以理解是一个先进先出的队列，通过管道进行通信,发送一个数据到Channel和从Channel接收一个数据都是原子性的。不要通过共享内存来通信，
而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的。

### 用法
#### select
select 可以实现多路复用，即同时监听多个 channel。

- 发现哪个 channel 有数据产生，就执行相应的 case 分支
- 如果同时有多个 case 分支可以执行，则会随机选择一个
- 如果一个 case 分支都不可执行，则 select 会一直等待  

select 的 case 语句读 channel 不会阻塞，尽管 channel 中没有数据。这是由于 case 语句编译后调用读 channel 时会明确传入不阻塞的参数，
此时读不到数据时不会将当前 goroutine 加入到等待队列，而是直接返回。

#### range
通过 range 可以持续从 channel 中读取数据，类似于遍历，当 channel 中没有数据时会阻塞当前 goroutine ，与读 channel 时阻塞处理机制一样。

### 无缓冲 Chan 的发送和接收是否同步?
channel 无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据；channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

### golang中new和make的区别？
- make 仅用来分配及初始化类型为 slice、map、chan 的数据。
- new 可分配任意类型的数据，根据传入的类型申请一块内存，返回指向这块内存的指针，即类型 *Type。
- make 返回引用，即 Type，new 分配的空间被清零， make 分配空间后，会进行初始。

### Go的Struct能不能比较？
- 相同struct类型的可以比较
- 不同struct类型的不可以比较,编译都不过，类型不匹配

### 空 struct{} 占用空间么？
可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数:
```go
fmt.Println(unsafe.Sizeof(struct{}{}))  //0
```
空结构体 struct{} 实例不占据任何的内存空间。

### 空 struct{} 的用途？
因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。

1.将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。  
2.不发送数据的信道(channel)
使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。  
3.结构体只包含方法，不包含任何的字段

### 值类型、引用类型
1、在Go语言中，值类型和引用类型有以下特点：
a、「值类型」:基本数据类型，int,float,bool,string,以及数组和struct 特点：变量直接存储值，内存通常在栈上分配，栈在函数调用完会被释放

b、「引用类型」：指针，slice，map，chan，interface等都是引用类型 特点：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配，通过GC回收。

### Go中两个Nil可能不相等吗？
Go中两个Nil可能不相等。

接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，
当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。

两个接口值比较时，会先比较 T，再比较 V。接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。
```go
func main() {
    var p *int = nil
    var i interface{} = p
    fmt.Println(i == p) // true
    fmt.Println(p == nil) // true
    fmt.Println(i == nil) // false
}
```
- 例子中，将一个nil非接口值p赋值给接口i，此时,i的内部字段为(T=*int, V=nil)，i与p作比较时，将 p 转换为接口后再比较，
因此 i == p，p 与 nil 比较，直接比较值，所以 p == nil。
- 但是当 i 与nil比较时，会将nil转换为接口(T=nil, V=nil),与i(T=*int, V=nil)不相等，因此 i != nil。因此 V 为 nil ，
但 T 不为 nil 的接口不等于 nil。

### 两个 interface 可以比较吗？
判断类型是否一样  
reflect.TypeOf(a).Kind() == reflect.TypeOf(b).Kind()

判断两个interface{}是否相等  
reflect.DeepEqual(a, b interface{})

将一个interface{}赋值给另一个interface{}  
reflect.ValueOf(a).Elem().Set(reflect.ValueOf(b))

### Go 两个接口之间可以存在什么关系? 
如果两个接口有相同的方法列表，那么他们就是等价的，可以相互赋值。如果接口 A的方法列表是接口 B的方法列
表的自己，那么接口 B可以赋值给接口 A。接口查询是否成功，要在运行期才能够确定。

### Go语言函数传参是值类型还是引用类型？
- 在Go语言中只存在值传递，要么是值的副本，要么是指针的副本。无论是值类型的变量还是引用类型的变量亦或是指针类型的变量作为参数传递都会发生值拷贝，
开辟新的内存空间。
- 另外值传递、引用传递和值类型、引用类型是两个不同的概念，不要混淆了。引用类型作为变量传递可以影响到函数外部是因为发生值拷贝后新旧变量指向了
相同的内存地址。

### go 打印时 %v %+v %#v 的区别？
- %v 只输出所有的值；
- %+v 先输出字段名字，再输出该字段的值；
- %#v 先输出结构体名字值，再输出结构体（字段名字+字段的值）；

### Printf(),Sprintf(),FprintF()都是格式化输出，有什么不同? 
虽然这三个函数，都是格式化输出，但是输出的目标不一样 Printf 是标准输出，一般是屏幕，也可以重定向。
Sprintf()是把格式化字符串输出到指定的字符串中。 Fprintf()是吧格式化字符串输出到文件中

### 字符串转成byte数组，会发生内存拷贝吗？
字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。那么问题来了。

### 什么是 rune 类型？
Go语言的字符有以下两种：

- uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。
- rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。


# Go进阶
## 垃圾回收
垃圾回收就是对程序中不再使用的内存资源进行自动回收的过程。  

### 1.1 常见的垃圾回收算法
- 引用计数
- 标记清除
- 分代收集

### 1.2 三色标记法
- 初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，将遍历到的对象标记为灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象标记为黑色对象。
- 循环上一步骤，直到灰色对象全部变成黑色对象。
- 通过写屏障(write-barrier)检测对象有变化，重复以上步骤。
- 收集所有的白色对象。

### 1.3 STW(Stop The World)
- 为了避免在GC过程中，对象之间的引用关系发生新的变化，从而导致GC的结果发生错误，停止所有正在运行的协程。
- STW对性能有一些影响，Go目前可以做到1ms以下的STW。

### 1.4 写屏障
- STW会影响程序性能，写屏障技术可以缩短STW的时间。

造成引用对象丢失的条件：一个黑色节点A新增了指向白色节点C的引用，并且白色节点C没有除了A以外的其他灰色节点的引用，
或者存在但是在GC过程中被删除了。以上两个条件需要同时满足：满足条件1时说明节点A已扫描完毕，A指向C的引用无法在被扫描到；
满足条件2时说明白色节点无其他灰色节点的引用了，即扫描结束后会被忽略。

写屏障技术破坏两个条件之一即可  
- 破坏条件1：Dijkstra写屏障  
满足强三色不变形：黑色节点不允许引用白色节点，当黑色节点新增了白色节点的引用，将对应的白色节点改为灰色
- 破坏条件2：Yuasa写屏障  
满足弱三色不变形：黑色节点允许引用白色对象，但是该白色对象有其他灰色节点间接的引用，当白色对象被删除了一个引用时，悲观的认为它一定会被黑色节点
新增引用，所以将它置为灰色。

### GC 的触发条件？
主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。
被动触发，分为两种方式：  
1.使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：
默认100%，即当内存扩大一倍时启用GC。    
2.使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。  

### Golang的内存模型中为什么小对象多了会造成GC压力？
通常小对象过多会导致GC三色法消耗过多的CPU。优化思路是，减少对象分配。

## GPM调度和CSP模型
### CSP模型
CSP模型是"以通信的方式共享内存"，不同于传统的多线程通过共享内存来通信。用于描述两个独立的并发实体通过共享的通讯channel进行通信的并发模型。

### GPM分别是什么，分别有多少数量？
- G(Goroutine)：Go协程，每个go关键字都会创建一个协程。
- M(Machine)：工作线程，在Go中称为Machine，数量对应于真实的CPU数。
- P(Processor)：处理器，包含运行Go代码的必要资源，用来调度G和M之间的关联关系，可以通过GOMAXPROC()来设置数量，默认为核心数。

M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。

### Goroutine调度策略
- 轮转队列：P会周期性的将G调度到M中执行，执行一段时间后，保存上下文，将G放到队列尾部，然后从队列中再取一个G进行调度。P还会周期性的查看全局
队列中是否有G等待调度到M中执行。
- 系统调用：当G0即将进入系统调用时，M0将释放P，某个空闲的M1获取P，继续执行P队列中剩下的G。M1的来源可能是M的缓冲池，也可能是新建的。  
当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓冲池睡眠。
- 工作量窃取：P所分配的任务G很快就执行完了，但是其他的P还有任务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。

### 协程和线程和进程的区别？
进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。
由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，
上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到
其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### Goroutine和线程的区别？
- 一个线程可以有多个协程
- 线程、进程都是同步机制，而协程是异步
- 协程可以保留上一次调用时的状态，当过程重入时，相当于进入了上一次的调用状态
- 协程是需要线程来承载运行的，所以协程并不能取代线程，「线程是被分割的CPU资源，协程是组织好的代码流程」

### 怎么查看Goroutine的数量？怎么限制Goroutine的数量？
- 在Golang中,GOMAXPROCS中控制的是未被阻塞的所有Goroutine,可以被 Multiplex 到多少个线程上运行,通过GOMAXPROCS可以查看Goroutine的数量。
- 使用通道。每次执行的go之前向通道写入值，直到通道满的时候就阻塞了。

## select + channel 实现协程退出
```go
package main
import (
 "fmt"
 "sync"
 "time"
)
func main() {
 var wg sync.WaitGroup
 stopWk := make(chan bool)
 wg.Add(1)
 go func() {
  defer wg.Done()
  worker(stopWk)
 }()
 time.Sleep(3*time.Second) //工作3秒
 stopWk <- true //3秒后发出停止指令
 wg.Wait()
}

func worker(stopWk chan bool){
 for {
  select {
  case <- stopWk:
   fmt.Println("下班咯~~~")
   return
  default:
   fmt.Println("认真摸鱼中，请勿打扰...")
  }
  time.Sleep(1*time.Second)
 }
}
```

## context结构原理
[](https://mp.weixin.qq.com/s?__biz=Mzk0NzI3Mjk1Mg==&mid=2247484509&idx=1&sn=8487966d50ad84c2dc277167b54c4663&scene=21#wechat_redirect)

```go
type Context interface {
   Deadline() (deadline time.Time, ok bool)
   Done() <-chan struct{}
   Err() error
   Value(key interface{}) interface{}
}
```
- Deadline方法：可以获取设置的截止时间，返回值deadline是截止时间，到了这个时间，Context会自动发起取消请求，返回值ok表示是否设置了截止时间。
- Done方法：返回一个只读的channel，类型为struct{}。如果这个chan可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。
- Err方法：返回Context 被取消的原因。
- Value方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。


## 竞态、内存逃逸
### 竞态
资源竞争，就是在程序中，同一块内存同时被多个goroutine访问。我们使用 go build、go run、go test命令时，
添加-race标识可以检查代码中是否存在资源竞争。

解决这个问题，我们可以给资源进行加锁，让其在同一时刻只能被一个协程来操作。  
- sync.Mutex
- sync.RWMutex

[同步sync包](https://mp.weixin.qq.com/s?__biz=Mzk0NzI3Mjk1Mg==&mid=2247484508&idx=1&sn=d0217e00c18446a1e2634f090c65359b&scene=21#wechat_redirect)

#### sync.Mutex
1.互斥锁，使同一时刻只能有一个协程执行某段程序，其他协程等待该协程执行完再依次执行。  
2.互斥锁只有两个方法 Lock （加锁）和 Unlock（解锁），当一个协程对资源上锁后，只有等该协程解锁，其他协程才能再次获得锁。  
3.Lock 和 Unlock 是成对出现，为了防止上锁后忘记释放锁，我们可以使用 defer 语句来释放锁。  

#### sync.RWMutex
1.上面我们使用互斥锁，来防止多个协程同时对 sum 做加法操作的时候产生数据错乱。RWMutex为读写锁，当读取竞争资源的时候，因为数据不会改变，
所以不管多少个 goroutine 读都是并发安全的。  
2.因为可以多个协程同时读，不再相互等待，所以在性能上比互斥锁会有很大的提升。  

#### sync.WaitGroup
- 声明 sync.WaitGroup ，然后通过 Add() 方法设置计数器的值，也就是说有多少个协程须要监听。
- 在每个协程执行完毕后，调用 Done() 方法来使计算器减 1。
- 最后调用 Wait() 方法一直等待，直到计数器为0，所以协程全部执行完毕。

#### sync.Once
- Do()方法保证函数只会执行一次。
- sync.Once 适合用于创建单例、只加载一次资源等只需要执行一次的场景。

#### 条件变量 sync.Cond

#### sync.Map安全锁
golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体。


#### go 中除了加 Mutex 锁以外还有哪些方式安全读写共享变量？
Go 中 Goroutine 可以通过 Channel 进行安全读写共享变量。

### 逃逸分享
「逃逸分析」就是程序运行时内存的分配位置(栈或堆)，是由编译器来确定的。堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，
而且会形成内存碎片。

对比栈和堆可知，在编译时，一切无法确定大小或大小可以改变的数据，最好放到堆上，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，
而且会形成内存碎片。

函数中申请一个新的对象：  
- 如果分配在栈中，则函数执行结束可自动将内存回收；
- 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；

逃逸场景：  
- 指针逃逸
- 栈空间不足逃逸
- 动态类型逃逸
- 闭包引用对象逃逸

总结  
- 栈上分配内存比在堆中分配内存效率更高
- 栈上分配的内存不需要 GC 处理，而堆需要
- 逃逸分析目的是决定内分配地址是栈还是堆
- 逃逸分析在编译阶段完成

传值 VS 传指针  
函数传递指针真的比传值效率高吗？如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，增加垃圾回收(GC)的负担，所以传递指针不一定 是高效的。

### 在Go函数中为什么会发生内存泄露？
Goroutine 需要维护执行用户代码的上下文信息，在运行过程中需要消耗一定的内存来保存这类信息，如果一个程序持续不断地产生新的 goroutine，
且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象。

### Goroutine发生了泄漏如何检测？
可以通过Go自带的工具pprof或者使用Gops去检测诊断当前在系统上运行的Go进程的占用的资源。

## Go语言中的内存对齐了解吗？
CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。

CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数

内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。

简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。

### json包变量不加tag会怎么样？
小写无tag，小写+tag，大写无tag，大写+tag。  
转为json后首字母小写的不管加不加tag都不能转为json里的内容，而大写的加了tag可以取别名，不加tag则json内的字段跟结构体字段原名一致。

### Log包线程安全吗? Golang的标准库提供了log的机制，但是该模块的功能较为简单(看似简单，其实他有他的设计思路)。在输出的
位置做了线程安全的保护。

### go convey 是什么?一般用来做什么?
- go convey 是一个支持 golang 的单元测试框架
- go convey 能够自动监控文件修改并启动测试，并可以将测试结果实时输出到 Web界面 
- go convey 提供了丰富的断言简化测试用例的编写

### defer 的作用是:
你只需要在调用普通函数或方法前加上关键字 defer，就完成了 defer 所需要的语法。当 defer 语句被执行时，跟 在 defer 后面的函数会被延迟执行。
直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论 包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的
异常结束。你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。

### 能说说uintptr和unsafe.Pointer的区别吗？
- unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；
- 而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；
- unsafe.Pointer 可以和 普通指针 进行相互转换；
- unsafe.Pointer 可以和 uintptr 进行相互转换。